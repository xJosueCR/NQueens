\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{textcomp}
\usepackage{graphicx}
\graphicspath{ {./images/} {./images2/} }
\usepackage[left=2cm,right=2cm,top=3cm,bottom=2cm]{geometry}
\author{Mario Arguello, Josué Céspedes Miranda}
\title{Proyecto 0}
\begin{document}
\begin{titlepage}
\begin{center}
\begin{large}
UNIVERSIDAD NACIONAL COSTA RICA \\
\begin{figure}[htp]
\centering
%\includegraphics[scale=0.50]{foto.jpg}
%\includegraphics[width=6cm]{../240px-UNA.png} 
\label{foto}
\end{figure}
\end{large}
\begin{large}
Facultad de Ciencias Exactas y Naturales
\end{large} 
\begin{large}
\vspace*{1cm}\\
Curso:\\
\vspace*{2mm}
Paradigmas de Programación\\
\end{large}
\vspace*{8mm}
\begin{large}
\textbf{Proyecto 1: 
NQueens
}\\
\end{large}
\begin{figure}[htp]
\centering
%\includegraphics[scale=0.50]{foto.jpg}
%\includegraphics[width=4cm]{../nqueens.png} 
\label{foto}
\end{figure}
\begin{large}
\vspace*{1cm}
Profesor:\\
\vspace*{5mm}
Eddy Miguel Ramírez\\
\end{large}
\begin{large}
\vspace*{1cm}
Estudiantes: \\
\vspace*{5mm}
Mario Arguello \\
Josué Céspedes Miranda \\
\end{large}
\vspace*{1cm}
II CICLO\\
\vspace*{1cm}
2020
\end{center}
\end{titlepage}
\tableofcontents
\pagebreak
\section{Resumen ejecutivo}
\bigskip
 	El presente trabajo esta realizado con el objetivo de hacer un uso práctico de distintos modelos con el fin de brindar una solución al popular problema NReinas bajo el uso de un paradigma funcional, que permita conocer nuevos conceptos y permita establecer diferentes perspectivas a la hora de brindar soluciones a distintos problemas mediante programación. \\
 	
 	El problema de NReinas es un acertijo con bastante popularidad, propuesto por el ajedrecista alemán Maxx Bezzel en 1848, consiste en colocar N reinas en un tablero con dimensiones NxN, su principal desafío radica en colocar las N reinas, mencionadas anteriormente, de tal manera que ninguna reina quede atacando otra. Dado que en el ajedrez esta pieza puede atacar a las piezas que se encuentren en su misma fila, misma columna, o en sus respectivas diagonales. \\
 	
 	En este documento se detallan dos posibles métodos para dar solución al problema explicado previamente. La primera, y más común a la hora de resolver este algoritmo, es una solución implementando backtracking, esta solución se ha diseñado y escrito en Scheme, el cuál como se mencionó al inicio tiene características de programación funcional y es un subconjunto del lenguaje de programación LISP; y que fue desarrollado en el MIT (Massachusetts Institute of Technology). La segunda solución ha sido implementada sobre algoritmos genéticos, se ha trabajado con elitismo y con un porcentaje de mutación de un 5\%, la solución para este caso esta escrita en Erlang, el cuál es también es un lenguaje de programación funcional de alto nivel, diseñado en los años 80 en los laboratorios de Ciencias y Computación de la compañía de telefonía sueca Ericsson, y fue diseñado para escribir aplicaciones concurrentes y distribuidas de funcionamiento ininterrupido. \\
 	
 	Además, este trabajo pretende plasmar las distintas diferencias presentes en los métodos utilizados para dar solución al problema, establecer una comparación basada en el tiempo de ejecución de cada una de las soluciones y que permita obtener como resultado cuál presenta mejores características de desempeño. Por otra parte, ambas soluciones representan una oportunidad para los estudiantes participantes en conocer nuevos paradigmas, poder incursionar en temas de mucho interés como en el caso de algoritmos genéticos que  son temas muy amplios y que lamentablemente es díficil encontrar en un curso dentro del programa de la carrera de Ingeniería en Sistemas de Información en la Universidad Nacional de Costa Rica que abarque la investigación e implementación de este tipo de algoritmos, que se encuentran relacionados a temas de inteligencia articial y que son utilizados para resolver problemas de búsqueda y optimización, que concuerdan con los parámetros necesarios para dar una solución al problema de NReinas. Por lo que este proyecto representa: 1) un reto, por la parte de investigación y la utilización de un paradigma distinto a la programación orientada a objetos(POO), que incluye un cambio en la forma de pensar, y 2) la oportunidad de aprender temas nuevos y relevantes que pueden llegar a tener un impacto positivo en un futuro profesional. \\
 	
 	Aquí se documentan la descripción de las soluciones, los principales problemas encontrados durante su desarrollo, aprendizajes obtenidos, se adjuntan los resultados de las pruebas efectuadas y demás aspectos concernientes para el proyecto.
 	
\pagebreak
\section{Introducción}

	El presente trabajo tiene como propósito presentar la solución del famoso problema de las n-reinas, el cual consiste en colocar $N $ reinas en un tablero de $NXN $ tal que ninguna de estas pueda ser “atacada” por otra reina y el debido análisis del proceso de resolución, el cual se hará mediante el uso del backtracking y los algoritmos genéticos en dos distintos paradigmas funcionales.

	Para comprender la resolución de este problema es necesario tener en cuenta el concepto de backtracking o “vuelta atrás”, el cual consiste en la búsqueda sistemática de posibles soluciones, donde a partir de un caso base se crean sub-casos  los cuales a su vez son tomados como base para nuevas posibles soluciones expandiéndose hasta encontrar un camino sin salida o una solución apropiada, dado esto ,el algoritmo da un paso hacia atrás con el fin de continuar con el análisis de la siguiente posibilidad. En el caso de los algoritmos genéticos, es una técnica de resolución de problemas que se basa en la evolución biológica, donde se inicia con un conjunto de posibles soluciones denominado población y una métrica llamada función de aptitud que permite evaluar cada posible solución, a partir de esto, se seleccionan los mejores candidatos de la población los cuales generaran otro grupo de posibles soluciones la cual es considerada la “siguiente generación”, este ciclo continua de tal manera que es posible que alguna de las generaciones presente una solución adecuada para el problema.  

	Entre las características mas importantes de la aplicación del backtracking para la resolución de este problema podemos mencionar el hecho de que es capaz de calcular todas las posibles soluciones (a costo de un tiempo mayor de resolución) y su facilidad de implementación, por el lado contrario, el algoritmo genético es capaz de encontrar una única solución  para cualquier cantidad de reinas en un tiempo mucho menor en comparación al del backtracking (esto será analizado mas adelante), sin embargo su implementación resulta un poco mas complicada.
\bigskip
\bigskip 


\pagebreak
\section{Marco teórico}
\bigskip
	Como se ha mencionado previamente, para dar solución al problema de NReinas se han utilizado dos lenguajes de programación funcionales. A continuación de profundiza un poco más en la historia, características de Scheme y Erlang y sus principales usos.\\
\begin{enumerate}
 \item  \textbf{Scheme} \\
 	Es un lenguaje de programación de alto nivel, se le considera un lenguaje altamente expresivo. Su sintaxis es fácil de leer pero no lo es tanto comparándolo con Python. Opera sobre estructuras como listas, cadenas, vectores, tuplas y posee conjuntos de datos que lo hacen muy versátil.
 	\begin{itemize}
	\item Historia: surgió en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerald J. Sussman buscaban un lenguaje con un semántica clara y sencilla. Originalmente se llamaba "Schemer", se le cambió el nombre ya que sus creadores usaban el sistema operativo ITS, que limitaba la longitud del nombre de los ficheros a 6 caracteres.
	\item Antecedentes: altamente influenciado por el cálculo lambda. Su desarrollo ha sido lento, ya que las personas encargadas de su estandarización es muy conservadora y ha sido difícil añadirle nuevas características. Se le considera una de los mejores lenguajes de propósito general. Fue el primer dialecto de Lisp que usó ámbito estático o léxico en lugar de dinámico de forma exclusiva. 
	\item Características: filosofía minimalista, su mecanismo principal para el control de flujo son las llamadas recursivas finales. Además, Scheme ofrece gestión automática de memoria, popularmente conocido como recolector de basura. Las listas son la estructura de datos básica, no hay sintaxis explícita para crear registros o estructuras o para programación orientada a objetos. La programación funcional pura no necesita de variables ni manejo de memoria compartida, por lo que hacen a Scheme una buena opción en presencia de procesos concurrentes. Una de las desventajas es que existen múltiples implementaciones diferentes, cada una utiliza extensiones y bibliotecas propias que se tornan incompatible entre sí.
	\item Usos: la mayoría de uso que se le da a Scheme se refiere a la parte educativa. Profesores de universidad, como es el caso del profesor R. Kent Dybvig que trabaja en la Universidad de Indiana, se concentra en el prototipado de nuevas semánticas para Scheme, incluso tiene a la venta un compilador de Scheme con su colega Daniel P. Friedman. También, hay muchos otros profesores de distintas universidades que lo usan como lenguaje de enseñanza. 
	\end{itemize}
 \item  \textbf{Erlang} \\
 Es un lenguaje de programación funcional de alto nivel, que se ubica también dentro del paradigma de Programación Declarativa, diseñado para escribir aplicaciones concurrentes y distribuidas de funcionamiento ininterrumpido. Erlang cuenta con tipado dinámico y asignación única, esto último consiste en que una vez asignado un valor a una variable, éste valor no puede cambiar.
 \begin{itemize}
 \item Historia
 \item Antedentes
 \item Características
 \item Usos
 \item Bibliotecas utilizadas
 \end{itemize}
\end{enumerate}

\pagebreak
\section{Descripción de la solución}
\begin{enumerate}
\item  \textbf{Scheme Backtracking}

Para esta solución se toma en cuenta un tablero vacío como base para la exploración de las distintas soluciones, donde colocamos una reina en la primer casilla de la primer columna, ahora siendo este el nuevo caso base, colocamos una reina en la primer casilla de la segunda columna, evaluamos la posible solución, la cual en este caso no lo es, ya que se encuentra en la misma fila que la reina colocada en la anterior columna del tablero, así que  “damos un paso atrás” , volviendo al caso donde teníamos una reina en la primer columna, con el fin de tomar un nuevo camino, lo cual seria colocar una reina en la segunda casilla de la segunda columna y de la misma forma que el caso anterior, evaluamos, cuando esta evaluación da positiva avanzamos a colocar una reina en la columna 3, 4, 5… N, de la misma forma, los “pasos hacia atrás”  están definidos en el rango de 1 a N casillas en las de una misma columna (filas del tablero para la misma columna), cuando estas posibilidades se han agotado, se da un paso hacia atrás de tal manera que debemos continuar la exploración de las posibilidades en la columna anterior, y así hasta que se agoten todas las posibilidades.

\begin{figure}[htp]
\centering
\graphicspath{ {imagenes/} }
\includegraphics[scale=0.50]{general.png}
%\includegraphics[width=6cm]{../imagenes/general.png}
\caption{Sub árbol de soluciones}
\label{foto}
\end{figure}

Para darle solución a este problema a través de la programación, no es necesario hablar de un tablero y reinas, podemos simular estos con un arreglo unidimensional de tamaño N (listas en este caso), donde cada campo representa la columna del “tablero” y un entero dentro de dicho campo nos dirá el numero de fila, básicamente hablamos de posiciones.

\begin{figure}[htp]
\centering
\graphicspath{ {imagenes/} }
\includegraphics[scale=0.70]{Vectores.png}
%\includegraphics[width=6cm]{../imagenes/general.png}
\caption{Representación de tablero en vector solución}
\label{foto}
\end{figure}

El proceso de validación se da mediante las “coordenadas” o posiciones que representa la posible lista solución, ya que el entero dentro de una posición x dentro de la lista representa la fila, simplemente verificamos que ningún elemento dentro de la lista se repita, y como posición de la lista representa la columna, nunca habrá que preocuparse porque esta se repita. Para el caso de la verificación en diagonal evaluamos conforme insertarnos en la lista solución, se toma E como la columna del nuevo elemento, N como el valor de la columna anterior, por lo que tenemos que para que no se ataque deba seguir la siguiente formula: $| N - E | \neq | V[N] – V[E]|$ donde $V[N],V[E]$ representa el elemento de la lista en la posición N y E, esto debido a que los valores de las posiciones de un tablero en diagonal poseen la propiedad de que al restarse dan el mismo resultado, esto para columnas seguidas.

Con el fin de explorar todas las posibilidades creamos una lista de tamaño 1 que contiene como único elemento el 1, haciendo referencia a que la reina se encuentra en la posición (1,1) del tablero, luego debemos evaluar todas las posibilidades de una lista de tamaño 2, por lo que agregamos un elemento a la lista en la posición 2, con el numero 1 en dicha posición,  validamos si el vector es valido y como podemos observar tenemos las posiciones (1,1) y (2,1) lo que nos indica que es invalido ya que están en la misma fila, así que haciendo uso del backtracking regresamos al estado anterior el cual era una lista con un 1 como único elemento, y ahora en vez de agregar un 1 continuamos con un 2, por lo que ahora tendríamos una lista con las posiciones (1,1) y (2,2) el cual tampoco es una opción valida ya que dichas posiciones están en la misma diagonal, nuevamente se hace el paso hacia atrás y se agrega a la lista un 3 por lo que ahora tenemos las posiciones (1,1) y (2,3) la cual es una opción valida para continuar, por lo que agregamos nuevamente un 1 a la lista por lo que tendríamos las posiciones (1,1), (2,3) y (1,1), este proceso se repite para N columnas y N filas por lo que, cuando tengamos una lista de tamaño N y sea una opción valida, representara una lista solución. Se podría decir que el proceso de backtracking arma todas las combinaciones de 1 a $N$ posibles de una lista solución de manera controlada, ya que en muchos de los casos, se interrumpe la operación cuando la combinación, o la porción combinacional es invalida.

\end{enumerate}

\pagebreak
\section{Resultados de las pruebas}


\pagebreak
\section{Conclusiones}

\end{document}
\end{document}